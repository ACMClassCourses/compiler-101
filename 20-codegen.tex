\chapter{目标代码生成}

前面的章节中，我们已经建构了抽象语法树 (AST)，并进行了类型检查。在此基础上，我们需要通过抽象语法树生成目标代码。

尽管我们的确可以从抽象语法树直接生成目标平台的代码，然而现实情况并非如此。假设我们有
$m$ 门语言，$n$ 个目标平台，那么如果采用直接生成代码，则需要写 $m\times n$
个转换程序，这对于现代编译器来说是无法承受的。但是如果我们选取一门中间语言作为转换的中转，那么我只要实现
$m$ 个从语言到中间语言的转换程序，以及 $n$ 个从中间语言到目标平台的转换程序，就可以满足需求。这样的中间语言被称为
IR (intermediate representation)。此外，对于后续的优化，也可以在 IR 上处理，这可以大大减少编译器优化工作。

本章中，我们以 LLVM Language (version 15) 为例，来展示如何从中间语言转换成目标代码。如需查看
LLVM 的完整文档，请访问 \url{https://llvm.org/docs/LangRef.html}。

\section{LLVM 15 概览}

LLVM 是一套编译器基础设施项目，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。

IR 是区分前后端的标志。语法检查、建构抽象语法树、生成 IR 都属于前端部分。通过 IR
生成目标代码、针对 IR 层面的优化都属于后端部分。

LLVM 提供的工具链可以检查 IR 问题、运行及调试 IR，因此我们推荐使用 LLVM IR
作为我们编译器的 IR。

LLVM 项目中有很多非常使用的工具——如 clang、llc、lli 等等。一般来是，最常用的工具是
clang，因为 clang 可以将代码编译到 LLVM IR，也可以将 LLVM 代码编译到目标平台。比如
\texttt{clang main.c -S -emit-llvm --target=riscv32-unknown-elf -o main.ll}
可以将 \texttt{main.c} 转换成 LLVM IR 并保存在 \texttt{main.ll} 中；而
\texttt{clang -S main.ll --target=riscv32-unknown-elf -o main.s}
可以将 \texttt{main.ll} 转换成汇编。llc 可以将 LLVM IR 转换成汇编，如
\texttt{llc -march=riscv32 main.ll -o main.s} 会将 \texttt{main.ll}
转换成汇编并存到 \texttt{main.s}。

LLVM IR 语言与高级语言不同，不存在多层嵌套的环境，语句以基础块 (basic block)
的形式组织，与汇编语言非常相近，同时又保留了高级语言的类型属性。选择 LLVM 15
的原因是从 LLVM 15 开始，LLVM IR 默认使用不透明指针
(Opaque Pointers)，大大减少了转换时的负担。具体请参见章节 \ref{LLVM-semantic}。

LLVM IR 的一大特性是静态单赋值 (Static Single Assignment,
SSA)，即变量能且仅能被赋值一次，这一特性可以让编译器的静态分析更方便。

当然，你也可以使用其他 IR 或是直接一步从 AST
转换成目标代码（因为我们的编译器只有一个目标平台）。

\section{LLVM 15 环境}

\subsection{在线 LLVM 环境}\label{online-LLVM-env}

在学习 LLVM 的过程中，一个方便的使用环境非常重要。Godbolt (
\url{https://godbolt.org/}) 提供了几乎所有的编译器，并且可以编译到大量平台。

\begin{figure}[htb]
\centering
\includegraphics[scale=0.3]{image/godbolt.png}
\caption{Godbolt 使用截图}
\label{godbolt_sreenshot}
\end{figure}

图片 \ref{godbolt_sreenshot} 是一个通过在线 LLVM 环境来了解 LLVM 语言的例子。在
gofbolt 上，页面被分为两栏——左栏是你的输入，右栏是你选择的编译器在你填入的参数下的输入。下面我们将会分别介绍左右栏的使用。

左栏有一个语言选择框（位于左栏的上部）和一个代码输入框。语言选择框可以选择所使用的编程语言。

右栏上部左边部分是编译器选择框，右边部分是编译器参数框。我们此时希望将代码编译到适用于 rv32gc
平台的 LLVM 语言，而且不希望编译器做出优化（否则可能会把一部分代码直接去掉）。由于我们的编译器的目标平台是
rv32gc，且 clang 可以通过 \texttt{-emit-llvm} 来输出 LLVM 语言，因此我们在编译器选择框选择
RISCV rv32gc clang (trunk)（trunk 这里表示最新的 clang），在编译器参数框中输入 \texttt{-emit-llvm -O0}。

关于语言特性的内容，请见章节 \ref{LLVM-semantic}。

\subsection{本地 LLVM 环境}

你可以安装 LLVM 15 及其以上版本。截止 LLVM 17，所有的 LLVM 15 特性均可使用。

对于使用 apt 包管理的用户（debian/Ubuntu/... 用户），请参考 \href{https://apt.llvm.org/}{LLVM apt 安装文档}。

对于使用 pacman 包管理的用户，可以执行 \texttt{sudo pacman -S llvm clang} 安装最新版本的 LLVM。

你可以执行 \texttt{clang --version} 来检查 clang 是否确实安装到系统中。正常情况下，该指令会显示你的
clang 版本、目标平台等信息。

\section{LLVM 15 语法}\label{LLVM-semantic}

\textit{本章节只介绍常用的 LLVM 15 语法。如需了解全部语法或更详细的 LLVM 语法，请访问
\url{https://llvm.org/docs/LangRef.html}。}

\textit{提示：你可以先大致了解 LLVM 15 语法，然后跳到「从抽象语法树到中间语言」章节
(\ref{AST-to-IR}) 了解如何完成抽象语法树到 IR
的转换。在阅读「从抽象语法树到中间语言」部分的过程中，如果对 LLVM IR
的语法有疑惑，再回到本部分查看详细信息。}

\subsection{LLVM 15 简单例子}

对于下面的代码，

\begin{lstlisting}[language=C]
int c;
int foo(int* a, int b) {
    if (a == 0) return 0;
    return  *a + b + c;
}
\end{lstlisting}

在 \texttt{-emit-llvm -O1} 参数下，会生成下面的代码（下面的代码去掉了生成代码的
attribute 部分和一些注释，这些内容我们在编译器大作业中应该用不到）

\begin{lstlisting}[language=llvm]
@c = dso_local local_unnamed_addr global i32 0, align 4, !dbg !0

define dso_local i32 @foo(ptr noundef readonly %0, i32 noundef %1) local_unnamed_addr #0 !dbg !15 {
  call void @llvm.dbg.value(metadata ptr %0, metadata !20, metadata !DIExpression()), !dbg !22
  call void @llvm.dbg.value(metadata i32 %1, metadata !21, metadata !DIExpression()), !dbg !22
  %3 = icmp eq ptr %0, null, !dbg !23
  br i1 %3, label %9, label %4, !dbg !25

4:                                                ; preds = %2
  %5 = load i32, ptr %0, align 4, !dbg !26
  %6 = add nsw i32 %5, %1, !dbg !31
  %7 = load i32, ptr @c, align 4, !dbg !32
  %8 = add nsw i32 %6, %7, !dbg !33
  br label %9, !dbg !34

9:                                                ; preds = %2, %4
  %10 = phi i32 [ %8, %4 ], [ 0, %2 ], !dbg !22
  ret i32 %10, !dbg !35
}
\end{lstlisting}

进一步地，我们还可以忽略一些 debug 参数、一些无用的参数（如
\texttt{dso\_local}   \texttt{local\_unnamed\_addr} 和
\texttt{align}）以及不必要的 debug 函数，这样可以得到以下的代码

\begin{lstlisting}[language=llvm]
@c = global i32 0

define i32 @foo(ptr %0, i32 %1) {
  %3 = icmp eq ptr %0, null
  br i1 %3, label %9, label %4

4:                                      ; preds = %2
  %5 = load i32, ptr %0
  %6 = add nsw i32 %5, %1
  %7 = load i32, ptr @c
  %8 = add nsw i32 %6, %7
  br label %9

9:                                      ; preds = %2, %4
  %10 = phi i32 [ %8, %4 ], [ 0, %2 ]
  ret i32 %10
}
\end{lstlisting}

我们会在本章每个元素一一解释。如果你设置了 \texttt{-O0}，你会看到一些如
\texttt{\%3 = alloca i32} 的语句，我们也会在本章中介绍。

\textit{提示：如果你在选择的语言为 C++，那么你会发现函数名和原来的函数名不一样（一般会有一个下划线前缀和一个与函数参数相关的类型），这是由于
C++ 的 name mangling 机制，具体请上网执行了解。Name mangling
 机制主要用于解决函数重载时命名冲突问题，通过改名的方式，让函数实际名称不会冲突。一个简单的解决方案是全部使用
 C 语言而不使用 C++，但是 C 语言没有成员函数，在处理成员函数时仍然要将语言调为 C++。}

\subsection{LLVM 15 基本语法}

LLVM 15 的基本语法包含
\begin{itemize}
  \item 类型，如 \texttt{i1}，\texttt{i32}，具体参见章节 \ref{LLVM-types}；
  \item 变量，如 \texttt{\@a = global i32 0} 以及
    \texttt{\%a = ...}，具体参见章节 \ref{LLVM-variables}；
  \item 常量，具体参见章节 \ref{LLVM-constants}；
  \item 函数定义，如 \texttt{define i32 \@foo(ptr \%0, i32 \%1) \{...\}}，具体参见章节
    \ref{LLVM-functions}；
  \item 标签 (label)，如 \texttt{4:}；
  \item 语句，如 \texttt{\%3 = icmp eq ptr \%0, null}，具体参见章节
    \ref{LLVM-statements}。
\end{itemize}

一个基本的 LLVM IR 翻译单元由若干类型声明、若干全局变量和若干函数定义组成。

函数定义由若干标签和若干语句组成。标签是可以被分支语句 (\ref{LLVM-br-statements})
跳转到的地方。在函数外部的变量为全局变量，在函数内部的变量为局部变量。所有的变量能且仅能被赋值一次（因此全局变量实际上是指向变量的指针）。

每行的分号 (\texttt{;}) 后的内容为注释。如没有注释，分号是不必要的。

\subsection{类型}\label{LLVM-types}

常用的类型有
\begin{itemize}
  \item 整数类型：用 \texttt{i<N>} 表示，如 \texttt{i32}，\texttt{i1}；
  \item 指针类型：用 \texttt{ptr} 表示；
  \item 数组类型：用 \texttt{[<\# elements> x <elementtype>]} 表示，如
    \texttt{[40 x i32]}。数组类型允许嵌套定义，如
    \texttt{[3 x [4 x i32]]}，表示 $3\times 4$ 的二维数组。另请参见
    \url{https://llvm.org/docs/LangRef.html#array-type}；
  \item 结构类型：对于普通的类，用 \texttt{\%<typename> = type \{ <type list> \}} 表示，如
    \texttt{\%mytype = type \{ \%mytype*, i32 \}}；对于不能对齐的类
    (packed struct)，用 \texttt{\%<typename> = type <\{ <type list> \}>}
    表示，如 \texttt{<\{ i8, i32 \}>} 表示一个 5 字节的结构体。
\end{itemize}

\subsection{变量}\label{LLVM-variables}

非匿名变量的命名必须符合 \texttt{[\%@][-a-zA-Z\$.\_][-a-zA-Z\$.\_0-9]*}，且不能与作用域中的其他变量名或函数名冲突。

匿名变量的命名必须符合 \texttt{[\%@](0|[1-9][0-9]*)}，且不能与作用域中的其他变量名或函数名冲突。

变量分为全局变量和局部变量。全局变量以 \texttt @ 开头，如 \texttt{@abc}；局部变量以 \texttt \% 开头，如 \texttt{\%abc}。

变量能且只能被赋值一次。

\subsection{常量}\label{LLVM-constants}

常量有
\begin{itemize}
  \item boolean 常量: 仅有 \texttt{true}，\texttt{false} 两个字符串，类型为 \texttt{i1}。
  \item int 常量：支持所有标准的整数。
  \item 空指针常量：仅支持字符串 \texttt{null}，类型为 \texttt{ptr}。
\end{itemize}

\textit{如需使用其他常量，请参见\href{https://llvm.org/docs/LangRef.html\#constants}{官方文档}。}

\subsection{函数定义}\label{LLVM-functions}

函数的定义如下：

\begin{lstlisting}[language=llvm]
define <ResultType> @<FunctionName>(...) { ... }
\end{lstlisting}

圆括号内为函数参数，参数用逗号分割，每项参数的形式为 \texttt{<type> [name]}。

典型的例子有：
\begin{itemize}
  \item 无入参函数 \texttt{int a()}，对应的函数为 \texttt{define i32 \@a() \{...\}}；
  \item 单入参函数 \texttt{void a(int x)}，对应的函数为 \texttt{define void \@a(i32 \%x) \{...\}}；
  \item 双入参函数 \texttt{int a(int x1, int x2)}，对应的函数为 \texttt{define i32 \@a(i32 \%x1, i32 \%x2) \{...\}}。
\end{itemize}

花括号内为函数的语句以及若干标签 (label)。

\textit{关于函数调用，请参见 call 语句 (\ref{LLVM-call-statements})。}

\subsection{语句}\label{LLVM-statements}

\textit{注：以下的介绍中的语法只是 LLVM IR 语法的一部分。关于全部语法，请访问
\url{https://llvm.org/docs/LangRef.html\#instruction-reference}。同时，每个语句的章节也会附上对应的官方文档链接。}

在 LLVM IR 中，我们一般会用到以下语句：（点击括号中的章节号可以跳转到对应章节）

\begin{itemize}
  \item 二元运算语句 (\ref{LLVM-binary-statements})
    \begin{itemize}
      \item \texttt{add} 语句
      \item \texttt{sub} 语句
      \item \texttt{mul} 语句
      \item \texttt{sdiv} 语句
      \item \texttt{srem} 语句
      \item \texttt{shl} 语句
      \item \texttt{ashr} 语句
      \item \texttt{and} 语句
      \item \texttt{or} 语句
      \item \texttt{xor} 语句
    \end{itemize}
  \item 控制流相关语句
    \begin{itemize}
      \item \texttt{br} 语句 (\ref{LLVM-br-statements})
      \item \texttt{ret} 语句 (\ref{LLVM-ret-statements})
    \end{itemize}
  \item 内存相关语句
    \begin{itemize}
      \item \texttt{alloca} 语句 (\ref{LLVM-alloca-statements})
      \item \texttt{load} 语句 (\ref{LLVM-load-statements})
      \item \texttt{store} 语句 (\ref{LLVM-store-statements})
      \item \texttt{getelementptr} 语句 (\ref{LLVM-gep-statements})
    \end{itemize}
  \item 其他语句
    \begin{itemize}
      \item \texttt{icmp} 语句 (\ref{LLVM-icmp-statements})
      \item \texttt{call} 语句 (\ref{LLVM-call-statements})
      \item \texttt{phi} 语句 (\ref{LLVM-phi-statements})
    \end{itemize}
\end{itemize}

\subsubsection{二元运算语句}\label{LLVM-binary-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#binary-operations}}。

语法：
\begin{lstlisting}[language=llvm]
<result> = <operator> <type> <operand1>, <operand2>
\end{lstlisting}

支持的运算符（对应形式中的 \texttt{operator}）有：
\begin{itemize}
  \item add：整数加法
  \item sub：整数减法
  \item mul：整数乘法
  \item sdiv：有符号整数除法
  \item srem：有符号整数取模
  \item shl：左移
  \item ashr：算术右移
  \item and：按位与
  \item or：按位或
  \item xor：异或
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
%_add_result_1 = add i32 %a, %b
\end{lstlisting}

该语句表示将 \texttt{\%a} 与 \texttt{\%b} 之和存入 \texttt{\%\_add\_result\_1}。

\subsubsection{\texttt{br} 语句}\label{LLVM-br-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#br-instruction}}。

语法：
\begin{lstlisting}[language=llvm]
br i1 <cond>, label <iftrue>, label <iffalse> ; Conditional branch
br label <dest> ; Unconditional branch
\end{lstlisting}

\begin{itemize}
  \item \texttt{cond} 必须是一个 \texttt{i1} 类型的变量；
  \item \texttt{iftrue}、\texttt{iffalse} 以及 \texttt{dest}
    必须是所在函数里的一个标签；
  \item 由于 \texttt{br} 语句的下一个执行的语句一定不是下一条语句，因此一个基础块
    (basic block) 里的指令中 \texttt{br} 之后的语句是没有意义的。
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
br i1 %a, label %label_1, label %label_2 ; Conditional branch
br label %label_3 ; Unconditional branch
\end{lstlisting}

第 1 行表示如果 \texttt{\%a} 是 \texttt{true}，则跳转到
\texttt{label\_1}，否则跳转到 \texttt{label\_2}。第 2 行表示直接跳转到
\texttt{label\_3}。

\subsubsection{\texttt{ret} 语句}\label{LLVM-ret-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#ret-instruction}}。

语法：
\begin{lstlisting}[language=llvm]
ret <type> <value> ; Return a value from a non-void function
ret void ; Return from void function
\end{lstlisting}

\begin{itemize}
  \item \texttt{value} 的类型必须与 \texttt{type} 和函数的返回类型相同；
  \item 与 \texttt{br} 语句类似，一个基础块里的 \texttt{ret}
    语句之后的所有语句都不可达，因此都没有意义。
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
ret ptr %a
ret i32 1
\end{lstlisting}

第 1 行表示返回 \texttt{\%a}。第 2 行表示返回一个常数 1。

\subsubsection{\texttt{alloca} 语句}\label{LLVM-alloca-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#alloca-instruction}}。

语法：
\begin{lstlisting}[language=llvm]
<result> = alloca <type> [, <ty> <NumElements>]
\end{lstlisting}

\begin{itemize}
  \item \texttt{result} 的类型是指针类型 (\texttt{ptr})；
  \item 如果有 \texttt{<ty> <NumElements>}，则表示该指针指向了
    \texttt{NumElements} 个 \texttt{type} 类型的空间。
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
%ptr_1 = alloca i32
%ptr_2 = alloca i32, i32 5
\end{lstlisting}

第 1 行表示获得一块 \texttt{sizeof(i32)} 字节的空间，\texttt{ptr\_1} 指向该空间。第 2
行表示获得一块 \texttt{sizeof(i32)*5} 字节的空间，\texttt{ptr\_2} 指向该空间。

\subsubsection{\texttt{load} 语句}\label{LLVM-load-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#load-instruction}}。

语法：
\begin{lstlisting}[language=llvm]
<result> = load <ty>, ptr <pointer>
\end{lstlisting}

\begin{itemize}
  \item \texttt{result} 的类型是 \texttt{ty})；
  \item \texttt{result} 被赋值为 \texttt{pointer} 所指向的值。
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
%ptr = alloca i32
store i32 3, ptr %ptr
%val = load i32, ptr %ptr
\end{lstlisting}

第 3 行表示将 \texttt{\%ptr} 所指向的值赋值给 \texttt{\%val}，此处 \texttt{\%val}
的值为 3。

\subsubsection{\texttt{store} 语句}\label{LLVM-store-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#store-instruction}}。

语法：
\begin{lstlisting}[language=llvm]
store <ty> <value>, ptr <pointer>
\end{lstlisting}

\begin{itemize}
  \item \texttt{pointer} 所指向的值会被赋值为 \texttt{value}。
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
%ptr = alloca i32
store i32 3, ptr %ptr
%val = load i32, ptr %ptr
\end{lstlisting}

第 2 行表示将 \texttt{\%ptr} 所指向的值赋值为 3。因此第 3 行中，\texttt{\%val}
的值为 3。

\subsubsection{\texttt{getelementptr} 语句}\label{LLVM-gep-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#getelementptr-instruction}}。

在编译器大作业中，以下的语法可以胜任全部要求：
\begin{lstlisting}[language=llvm]
<result> = getelementptr <ty>, ptr <ptrval>{, <ty> <idx>}*
\end{lstlisting}

\texttt{getelementptr} 语句较为复杂，我们先看一个例子。

对于以下的 C 代码：
\begin{lstlisting}[language=C]
struct RT {
  char A;
  int B[10][20];
  char C;
};
struct ST {
  int X;
  double Y;
  struct RT Z;
};

int *foo(struct ST *s) {
  return &s[1].Z.B[5][13];
}
\end{lstlisting}
对应的 LLVM IR 为
\begin{lstlisting}[language=llvm]
%struct.RT = type { i8, [10 x [20 x i32]], i8 }
%struct.ST = type { i32, double, %struct.RT }

define ptr @foo(ptr %s) {
entry:
  %arrayidx = getelementptr %struct.ST, ptr %s, i64 1, i32 2, i32 1, i64 5, i64 13
  ret ptr %arrayidx
}
\end{lstlisting}

可以发现 \texttt{getelementptr} 语句会对类型逐层解析。将 ST 的指针先取下标为 1 的元素，然后访问成员
\texttt{Z}。由于成员是 \texttt{ST} 的第 2 个元素 (0-based)，因此取下标 2。接下来是取成员
\texttt{B}，同理由于其为第 1 个元素，取下标 1。\texttt{B} 的类型为一个二维数组，因此取下标 5 后再取下标 13
即可获得所需的指针。

上面的代码与下面的代码（逐步解引用）等价：
\begin{lstlisting}[language=llvm]define ptr @foo(ptr %s) {
  %t1 = getelementptr %struct.ST, ptr %s, i32 1
  %t2 = getelementptr %struct.ST, ptr %t1, i32 0, i32 2
  %t3 = getelementptr %struct.RT, ptr %t2, i32 0, i32 1
  %t4 = getelementptr [10 x [20 x i32]], ptr %t3, i32 0, i32 5
  %t5 = getelementptr [20 x i32], ptr %t4, i32 0, i32 13
  ret ptr %t5
}
\end{lstlisting}

\begin{itemize}
  \item \texttt{ty} 为 \texttt{ptrval} 所指向内容的类型，因此
    \texttt{\%t1 = getelementptr \%struct.ST, ptr \%p, i32 5}
    表示通过 \texttt{\%struct.ST} 指针获得指向第 5 个 \texttt{ST}
    的指针（如果需要访问的是指针指向的第 5 个元素，则应当使用
    \texttt{\%t1 = getelementptr \%struct.ST, ptr \%p, i32 0, i32 5}；
  \item \texttt{result} 为指向对应成员的指针（一定要注意这一点）；
  \item 为了方便编写代码，推荐逐步解引用。
\end{itemize}

\subsubsection{\texttt{icmp} 语句}\label{LLVM-icmp-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#icmp-instruction}}。

语法：
\begin{lstlisting}[language=llvm]
<result> = icmp <cond> <ty> <op1>, <op2>
\end{lstlisting}

\begin{itemize}
  \item \texttt{cond} 可以是
    \begin{itemize}
      \item \texttt{eq}：相等
      \item \texttt{ne}：不相等
      \item \texttt{ugt}：无符号大于
      \item \texttt{uge}：无符号大于等于
      \item \texttt{ult}：无符号小于
      \item \texttt{ule}：无符号小于等于
      \item \texttt{sgt}：有符号大于
      \item \texttt{sge}：有符号大于等于
      \item \texttt{slt}：有符号小于
      \item \texttt{sle}：有符号小于等于
    \end{itemize}
  \item \texttt{op1} 和 \texttt{op2} 的类型必须为 \texttt{ty}；
  \item \texttt{result} 的类型为 \texttt{i32}。
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
<result> = icmp eq i32 4, 5
\end{lstlisting}

该语句的结果为 \texttt{false}。

\subsubsection{\texttt{call} 语句}\label{LLVM-call-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#call-instruction}}。

语法：
\begin{lstlisting}[language=llvm]
<result> = call <ResultType> @<FunctionName>(<arguments>)
call void @<FunctionName>(<arguments>)
\end{lstlisting}

\begin{itemize}
  \item 参数列表 (\texttt{arguments}) 中每个参数的格式为
    \texttt{<ty> <val>}，参数列表的类型以及参数个数必须与函数定义对应；
  \item \texttt{result} 的类型必须为 \texttt{ResultType}（除非函数不会返回）。
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
%result = call i32 @foo1(i32 %arg1)
call void @foo2(i8 97)
\end{lstlisting}

\subsubsection{\texttt{phi} 语句}\label{LLVM-phi-statements}

\textit{完整文档位于 \url{https://llvm.org/docs/LangRef.html\#phi-instruction}}。

语法：
\begin{lstlisting}[language=llvm]
<result> = phi <ty> [ <val0>, <label0>], ...
\end{lstlisting}

\begin{itemize}
  \item \texttt{phi} 一般放于基本块的开头，用于通过特定的跳转来源来给变量赋值；
  \item 如果从特定的 label 跳过来，则赋值为对应的值；
  \item \texttt{result} 的类型必须为 \texttt{ResultType}（除非函数不会返回）。
\end{itemize}

例子：
\begin{lstlisting}[language=llvm]
Loop:       ; Infinite loop that counts from 0 on up...
  %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]
  %nextindvar = add i32 %indvar, 1
  br label %Loop
\end{lstlisting}

这段代码表示一个从 0 开始不停增加的循环，如果第 2 行的代码是从 \texttt{LoopHeader}
这一基本块跳来的，则赋值为 0；如果是从 \texttt{Loop} 这一基本块跳来的，则赋值为
\texttt{\%nextindvar}。

\texttt{phi} 语句可以大大减少 \texttt{alloca} 的使用，减少内存访问的次数，进而提升效率。因此
\texttt{phi} 语句在编译器优化过程中非常常见。

\section{从抽象语法树到中间语言}\label{AST-to-IR}

生成中间语言 (IR) 的过程是非常 “机械” 的，整体的逻辑见章节
\ref{AST-to-IR-details}。主要的工作在于为每个语法特性编写相应的转换逻辑
(\ref{AST-to-IR-specific-grammar})。除此以外，还需要解决
IR 的转换过程的一些小问题——如命名问题 (\ref{AST-to-IR-naming})、
初始化问题 (\ref{AST-to-IR-initializing})、内建函数相关问题
(\ref{AST-to-IR-for-builtin})。

在转换的过程中，你可以使用线上平台来辅助思考转换的逻辑。关于线上平台，参见章节
\ref{online-LLVM-env}。如果你不希望出现匿名变量，可以加上
\texttt{-fno-discard-value-names} 参数。

\textit{注意：由于现在绝大多数电脑都是 64 位的，而我们的目标平台是 32
位的，因此如果你想要在自己的电脑上运行 IR，你需要加上 \texttt{-m32} 参数（如果你的电脑兼容
32 位指令集）或使用模拟器（如 qemu）。}

\subsection{转换方式概览}\label{AST-to-IR-details}

LLVM IR 的全局一共只有全局变量和全局函数两种内容。全局变量对应 Mx*
中的全局变量和字符串字面量，转换时需要注意初始化过程
(\ref{AST-to-IR-initializing})；全局函数对应 Mx* 中的函数和成员方法。

除此以外，我们还需要处理内建函数和内建方法，但这个部分较为简单，详见章节
\ref{AST-to-IR-for-builtin}。

\subsection{为 IR 的变量、类及函数命名}\label{AST-to-IR-naming}

在 LLVM IR 中，要求全局变量和局部变量内部不能出现命名冲突。但是高级语言中，作用域使得命名会发生冲突，并遵循
variable shadowing 原则。一些语言会允许类名称与变量名重复。此外，在命名过程中，还要防止
IR 中内建的变量、类以及函数与用户的命名不会冲突。

对于命名冲突，一般有以下集中解决方案：
\begin{enumerate}
 \item 给变量加上前缀或后缀（通常是后缀）。这在 variable shadowing 下非常常见。比如，有一个作用域中已经有变量
   \texttt x，其内部又有一个作用域中声明了另一个变量 \texttt x，可以将其重命名为
   \texttt{x.1}。
 \item 选择一些高级语言不可使用的名称作为 identifier。这在内建函数和类的成员方法中非常常见。常见的不可使用的名称有不可出现在
   identifier 中的符号（如 \texttt{.}）、关键词。比如类 \texttt A 的成员方法
   \texttt{B}，就可以命名为 \texttt{A.B}；内建类 \texttt{string} 的成员方法
   \texttt{ord}，就可以命名为 \texttt{string.ord}（因为 \texttt{string}）是关键词。
\end{enumerate}

Mx* 中的函数都是全局的，因此不会出现命名冲突。类的方法可以通过
\texttt{<ClassName>.<MethodName>} 来解决冲突。受到 variable shadowing
影响的变量可以通过在后面加上 \texttt{.<n>} 来解决冲突。n 的值可以在语法检查时完成。

\subsection{为变量进行初始化}\label{AST-to-IR-initializing}

对于全局变量，由于 LLVM IR 中的全局变量需要指定一个初始的值，因此我们可以利用这个值。

如果变量被一个定值初始化，那么我们就直接将这个常量初始化。比如我们有这样的一个全局变量
\begin{lstlisting}[language=C]
int i = 1;
\end{lstlisting}
对应的 LLVM IR 为
\begin{lstlisting}[language=C]
@i = global i32 0
\end{lstlisting}

如果变量初始化的值无法在此时决定，那么我们需要借助运行期来完成初始化。一个可行的解决方案是将初始化过程放到初始化函数中。如前文中对命名的解决方案
(\ref{AST-to-IR-naming})，我们可以给这个函数起名为 \texttt{\_init}，然后在
\texttt{main} 函数中调用 \texttt{\_init}。比如我们有一个这样的全局变量
\begin{lstlisting}[language=C]
int i = j;
\end{lstlisting}
对应的 LLVM IR 为
\begin{lstlisting}[language=C]
@i = global i32 0

define void @_init() {
entry:
  %0 = load i32, ptr @f
  store i32 %0, ptr @c
  ret void
}
\end{lstlisting}

\subsection{为每个语法特性编写相应的转换逻辑}\label{AST-to-IR-specific-grammar}

\subsubsection{处理语句}\label{AST-to-IR-statements}

\subsubsection{处理表达式}\label{AST-to-IR-expression}

\subsection{为内建函数及内建成员方法生成对应的 IR}\label{AST-to-IR-for-builtin}

为内建函数及内建成员方法生成对应的 IR 的最方便的办法是使用 C
语言编写内建函数和内建成员方法，然后使用 clang 转换。

不过，由于 C 函数名不能包含 \texttt{.}，因此对于内建类的内建成员方法，我们可以用下划线或其他可以出现在函数名中的字符代替。比如成员方法
\texttt{string.ord} 可以被改名成 \texttt{string\_ord}，然后在生成 IR 之后将
\texttt{string\_ord} 转换为 \texttt{string.ord}。

具体来说，你可以执行以下指令（假设你编写的 C 语言文件名位 \texttt{builtin.c}，且内建类有 \texttt{string} 和 \texttt{array}）
\begin{lstlisting}[language=sh]
clang -emit-llvm --target=riscv32-unknown-elf -O2 -fno-builtin-printf -fno-builtin-memcpy \
    builtin.c -o builtin_intermediate.ll
sed 's/string_/string./g;s/array_/array./g' builtin_intermediate.ll > builtin.ll
rm builtin_intermediate.ll
\end{lstlisting}

\section{从中间语言到目标代码}

\subsection{RISC-V 汇编}

\subsection{RISC-V Calling Convention}
