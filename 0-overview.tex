\chapter{课程要求}
% \begin{introduction}
%     \item TBA
% \end{introduction}

编译器设计课程在 ACM 班有非常悠久的历史，该课程要求学生自主完成一个从源代码到汇编代码的编译器，引导学生直观理解系统执行二进制代码的过程并掌握一系列代码级别优化方法。
与传统编译原理课程不同的是，本课程不会提供任何的已有框架。课程设计目标要求自主设计数据结构（自主设计抽象语法树、中间表达，自主探索语言特定的优化策略）。

\begin{remark}
  \begin{enumerate}
    \item 在本课程中，允许使用 \texttt{antlr} 等前端分析库，但是不得使用现有的编译库。
    \item 作业仓库：\url{https://github.com/ACMClassCourses/Compiler-Design-Implementation}。其中 testcases 目录下提供了不同阶段的评测点，
      每个阶段的目录下提供了测试脚本，脚本中的注释提供了用法提示。
    \item 运行环境（模拟器）：\url{https://github.com/Engineev/ravel}。
  \end{enumerate}
\end{remark}

\section{为什么需要编译器？}

程序设计中，我们总是会将语言区分为低级语言 (low-level programming language) 与
高级语言 (high-level programming language)。

低级语言一般鲜有对体系结构的抽象，总是与硬件相耦合。正因如此，
低级语言可以不借助任何复杂的工具（如编译器）而直接转化为机器码。不过，其问题在于，
难以移植到其他的硬件平台，而且可读性较差。

高级语言会将操作进行高度抽象，形成一种人类可读且易于移植的语言。因此，相较于低级语言，
高级语言的编写效率是非常高的。这也是我们平时接触的绝大多数语言都是高级语言的原因。然而，正是因为这样的抽象，
其无法很方便地转化到机器码。

假设我们有一段 C 语言编写的 hello world 的程序 hello\_world.c，如果我们想要在机器上运行这段程序，
其需要经历以下阶段：
\begin{enumerate}
  \item 由 C 的预处理器 (\textbf{C} \textbf{p}re\textbf{p}rocesser, cpp)
    将所有宏展开（如 \texttt{\#include} 宏会将对应的文件拷贝过来），生成预处理后的文件（如 hello\_world.i）。
  \item 由编译器将预处理后的结果转化为汇编 (assembly)（如 hello\_world.s）。
  \item 由汇编器将汇编转化为目标代码 (object code)（如 hello\_world.o）。
  \item 由链接器将若干份目标代码链接为可执行文件。此阶段中，会处理不同翻译单元中的互相引用变量及函数。
  \item 由操作系统动态链接需要的依赖库后，运行程序。
\end{enumerate}

可以看到，一个编译器实际上是将预处理后的代码转化为汇编的工具。这可能和我们平时接触的编译器的概念不太一样。
我们通常接触的编译器可以直接从源代码直接生成可执行文件，这是因为同时集成了预处理器、汇编器、链接器。
我们编译器要求实现的仅限从预处理后的结果（或者无需预处理的代码）到汇编的阶段。

\section{编译器具体阶段}

以下是实现编译器的步骤的概述：

\begin{enumerate}
    \item 词法分析：第一步是将源代码转换为一个词素流，在这个阶段需要指定基本的词素单元。
    \item 句法分析：根据生成的词素流分析源代码的结构并且按照语言的语法规则转换为层次化的结构，生成解析树或抽象语法树(AST)。
    \item 语义分析：解析后，进行语义分析以检查程序的正确性。这包括类型检查、名称解析、作用域分析和其他语义检查。在这个阶段需要构建一个符号表并执行各种检查，以确保程序的正确性。
    \item 中间表示：在这个阶段，将AST转换为中间表示 (IR)。IR是程序的一个抽象表示，更容易分析和优化。常见的 IR 大多使用虚拟寄存器的抽象。
    \item 代码优化：根据生成的中间表示对程序进行优化，其中关键一步是分配寄存器（如果采用虚拟寄存器抽象需要转换为真实的寄存器）。此外，优化还包括死代码消除、函数内联等。
    \item 代码生成：优化后，生成目标汇编代码。该步骤需要将源语言/中间表达映射到目标体系结构的相应汇编指令，需要指令选择，以生成高效的汇编代码。
\end{enumerate}

\section{编译器作业阶段及对应要求}

为了方便大家分阶段开发，我们将会把作业划分为三个阶段。语义检查阶段（对应1、2、3）、目标代码生成阶段（阶段4、6）、寄存器分配（阶段5）。各个阶段的要求如下：
\begin{table}[!ht]
    \resizebox{\textwidth}{!}{\begin{tabular}{c|c|c}
        \hline
                 & 目标                                                                          & 要求                                                                            \\ \hline
        语义检查阶段   & \begin{tabular}[c]{@{}c@{}}将源代码转换为一个具有语义信息的\\ 抽象结构并实现对语言的语法检查。\end{tabular} & \begin{tabular}[c]{@{}c@{}}通过编译器可以识别存在语法错\\ 误的代码。\end{tabular}                \\ \hline
        目标代码生成阶段 & \begin{tabular}[c]{@{}c@{}}将高级语言转换为汇编语言并且实现\\ 简单的指令选择。\end{tabular}         & \begin{tabular}[c]{@{}c@{}}可以生成对应的可终止汇编代码\\ （不对性能做出要求）。\end{tabular}          \\ \hline
        寄存器分配    & \begin{tabular}[c]{@{}c@{}}在目标代码或中间表达等结构的基础\\ 上实现高效的寄存器分配算法。\end{tabular}   & \begin{tabular}[c]{@{}c@{}}在测评程序集上与标准Clang编译的\\ 结果进行性能比对（按照周期数）。\end{tabular} \\ \hline
        \end{tabular}}
\end{table}
