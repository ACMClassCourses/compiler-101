\chapter{语义检查(Semantic)}
\noindent
(先写一点备注) \\
1. 强烈建议认真阅读Yx的代码和Tutorial.md。 \\
Yx是一个比Mx更加简单的语法，阅读Yx的实现对于代码的完成非常有帮助。\\
Yx的github地址：https://github.com/ZYHowell/Yx \\
2. 一些建议：多和同学、助教交流；没有头绪时多看看Yx和学长学姐的代码，有助于理解并提高效率；
切忌抄袭。\\

\section{Introduction}
在一个编译器的结构中，semantic阶段主要完成了词法分析(lexer)、语法分析(parser)、语义分析(semantic)的部分。
这一部分的评测要求是，正确地判断一段Mx代码是否存在词法、语法、语义上的错误。\\

lexer和parser的部分，我们将使用antlr4帮助我们完成；然后，我们将利用antlr4为我们生成的代码，构建AST(以下会有详解)，并
进行semantic check。
接下来，我们将首先讲解对于semantic阶段工作的整体理解，再对具体的实现步骤逐步解析。

\section{Overview}
semantic部分的难点，主要在于如何构建AST。AST即abstract syntax tree，指抽象语法树。通俗地说，我们将源代转换成用树的结构来表示，
这棵树叫做AST。antlr4能够为我们完成lexer和parser，并提供接口便于我们提取其中的信息，我们希望能够自定义树的每个结点，并储存需要的
信息，所以我们将继承antlr4生成的类，然后构建一棵属于我们的AST。\\

在一切工作开始之前，我们先根据Mx语言的规定，整体了解一下我们的AST。 \\

一份Mx代码将被转换成一棵AST，这棵树从RootNode开始，随着树的层数的加深，
每层的结点所表示的单位逐渐变小。下面是基于Mx的一个AST层级的简单示意：
\begin{verbatim}
RootNode 
- VariableDef
- ClassDefinition
    - VariableDefinition
    - FuncDefinition
- FunctionDefinition - Statements - Expressions 
\end{verbatim}

Mx语言下，对这个结构进行一点简单的注解：\\
1. RootNode从全局作用域开始。Mx的全局作用域中只存在全局变量、类定义、全局函数三种类型。\\
2. 类定义中，只存在变量和函数。 \\
3. 一个函数包含多个statement(语句)。在AST中，一个函数中的每个statement都是这个函数节点的子节点。
statement有许多种类型，比如if语句、循环语句(for、while)等等。\\
4. expression(表达式)有许多种类型，比如基本表达式(primary)、常量表达式(constant)、赋值表达式(assignment)等等。 \\
5. 关于Mx所使用的statement和expression，Mx文档中均有明确的规定，概念模糊的同学可以先仔细阅读。 \\

如果你对以上结构感到费解，可以仔细阅读Yx库中的g4文件(Yx/src/parser/Yx.g4)辅助理解，或者继续阅读下一部分中对于如何构建AST的详细介绍，
准确地理解AST的结构将会大大提高效率。\\

\section{Practical Methods}
以下是semantic部分的具体实现过程。

\subsection{About antlr4}
antlr4是一个强大的解析器生成器。在我们的实现中，我们需要先写一个Mx.g4文件，用来描述Mx的语法，然后运行ANTLR命令，
生成MxLexer.java, MxParser.java等文件。\\

antlr4的安装、运行等等内容，请阅读《antlr4权威指南》第一部分的相应内容(pdf已下发，17页开始)。\\

antlr4的其他详细内容，请参照《antlr4权威指南》。

\subsection{Write the Grammar}
关于g4文件如何书写，《antlr4权威指南》中已经给出了详细的指导，可以结合Yx的代码理解。\\

下面简单介绍一下g4文件各部分内容的意义：\\
1. \\

提醒： \\
1. 关于优先级问题 \\
2. 使用 "\#"  \\
3. 使用 "<assoc=right>" \\


\subsection{The Parse Part in compiler}
1. 生成文件解释 \\
对完成的g4文件，运行antlr4后，将生成一系列文件，下面对几个文件进行一个简单地介绍。 \\


2. 调用生成代码完成lexer和parser \\
如何在我们的代码中调用antlr4生成的文件来完成lexer和paerser？Yx的main文件已经给出了示例。
下面的代码是Yx的部分代码：\\
\begin{verbatim}
    YxLexer lexer = new YxLexer(CharStreams.fromStream(input));     // 1
    lexer.removeErrorListeners();                                   // 2
    lexer.addErrorListener(new YxErrorListener());                  // 3    
    YxParser parser = new YxParser(new CommonTokenStream(lexer));   // 4
    parser.removeErrorListeners();                                  // 5
    parser.addErrorListener(new YxErrorListener());                 // 6
    ParseTree parseTreeRoot = parser.program();                     // 7
\end{verbatim}
注解： \\


3. 自定义error \\
antlr4在lexer和parser的过程中，能够发现词法、语法错误，而具体的报错函数可以自定义。
这里可以参考Yx对于YxErrorListener类的处理。

\subsection{Design and Build the AST}
\subsubsection{About the Tree}
从AST的具体实现方式来说，

\subsubsection{ASTNode}

\subsubsection{Scope}
Scope表示作用域。一般而言，由 \{ 和 \} 组成的块会引进一个新的作用域，当然，在Mx文档中关于作用域有更加详细准确的描述。\\

对于我们semantic阶段的实现来说，处理Scope的意义是，我们需要保存每个作用域内定义的变量、函数等等信息，
来确保每次在当前作用域或者更内层的作用域中调用某个变量或函数时，我们能够找到它们对应的定义，并判断是否存在语义错误
(类型错误、重名等问题)。\\

在Yx的示例代码中，关于Scope采用了一个类似树的结构来维护，根据作用域的关系建树。
具体的实现思路是：定义一个Scope类，用以储存每个作用域内需要的信息。
以globalScope(全局作用域)作为根节点。维护一个currentScope表示当前作用域，如果产生了一个新的作用域（比如
在IfStmtNode中，一个if-else语句会产生两个内层的作用域），则新建一个Scope作为新的currentScope，完成
该内层作用域内的工作后，再将currentScope退回先前的作用域，通过成员变量parentScope记录作用域之间的关系并实现回溯。
这样，每当我们需要为一个被调用的变量寻找它的定义，我们可以通过parentScope从当前作用域不断向前回溯，直到找到
这个变量对应的定义。\\

需要强调，Mx语言中内层作用域可以遮蔽外层作用域的名字，这也是我们采用上述方法来实现Scope的一个重要原因。\\

如果感到困惑，请结合Yx的代码对这一部分进行理解。

\subsubsection{ASTBuilder}


\subsection{Semantic Check}
进行到这一步，我们已经建好了AST，接下来我们将进行语义检查。\\

\subsubsection{SymbolCollector}
SymbolCollector是一个全局作用域内的收集，它存在的意义是，Mx会在全局定义类，自定义类也会出现在各个函数和变量定义中(包括出现在其他的类定义中)，作为变量类型或者函数的返回类型，所以
在遍历AST进行语义检查之前，我们希望能够先收集并保存所有的自定义类。当然，收集过程中也需要做一些语义检查，比如重名、出现不存在的类型等。 \\

之所以将这部分从SemanticChecker独立出来，是因为 收集自定义类 这个步骤，需要在 遍历所有节点并进行语义检查 之前进行。
事实上，这部分的设计非常自由，你可以进行更多你认为合理的操作。

\subsubsection{SemanticChecker}





